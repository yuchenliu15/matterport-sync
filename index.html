<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width = device-width, initial-scale = 1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title> Hello </title>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
    <script src="/socket.io/socket.io.js"></script>
    <script src='https://static.matterport.com/showcase-sdk/2.0.0-0-g7edd6b8/sdk.js'></script>
</head>

<body>

    <iframe style="width:600px; height:480px" src="https://my.matterport.com/show/?m=jAwDxbtWfEq&utm_source=4&play=1"
        frameborder="0" allowfullscreen allow="vr" id="showcase_iframe"></iframe>

    <button id="button">SET AS LEADER (Set hash to 1)</button>

    <script>
        $(() => {
            let hashid = 0;
            let last_pose = null;
            let received_pose = null;
            let current_mode = null;
            let sweepid_cache = null;
            const socket = io();
            const mp_iframe = $('#showcase_iframe');

            const button = $('#button');
            button.on('click', () => { //Set the current page as the leader
                hashid = 1;
                console.log(hashid);
            });

            const iframe = mp_iframe.get(0);
            const api_key = '6f5de7bf268545b8ba336d829f673088';
            mp_iframe.add('load', showcaseLoader); //after iframe finish loading, call showcaseLoader()

            socket.on('hash', msg => {
                hashid = msg; //Each unique hash assigned on connection to the socket.io and server
                console.log(hashid); //The first person signed in is the leader
            });

            function showcaseLoader() {
                try {
                    window.MP_SDK.connect(
                        mp_iframe.get(0), // iframe
                        api_key, // Your API key
                        '3.2' // SDK version
                    )
                        .then((sdk) => {

                            //sdk.Camera.pose = test_pose;
                            let count = 0

                            sdk.Camera.pose.subscribe((pose) => { //sends pose data continuously when camera moves
                                count += 1;
                                last_pose = pose;
                                console.log("NEW SWEEP" + pose.sweep);
                                if (hashid === 1 /*&& count === 25*/) { //count is to slowdown sending data
                                    count = 0;

                                    socket.emit('sweepid', pose);
                                }
                            });
                            /*
                            sdk.on(sdk.Camera.Event.MOVE, () => {
                                console.log('CAMERRRRRRRRRRAAAAAAAA');
    
                            });
                            */

                            sdk.on(sdk.Sweep.Event.ENTER, async (e1, e2) => {
                                console.log('LEAVING ' + e1 + ' ' + e2);
                            });

                            sdk.on(sdk.Mode.Event.CHANGE_END, (e1, e2) => {

                                if (hashid === 1 && e2 === 'mode.dollhouse') {
                                    socket.emit('viewmode', last_pose.sweep);
                                    console.log('MODE CHANGEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE: ' + e1 + e2);
                                }

                            });

                            socket.on('viewmode', (msg) => {
                                sweepid_cache = msg;
                                console.log('The view mode of sweeeeeeeeeeeeeeeeeeeeep');
                            });


                            sdk.on(sdk.Sweep.Event.ENTER, async () => {
                                if (hashid === 1) {
                                    setTimeout(() => {
                                        console.log("Test which is last");
                                        socket.emit('sweepid', last_pose);
                                    }, 800);
                                }

                                else {
                                    if (received_pose && received_pose.mode !== 'mode.transitioning') {
                                        await sdk.Mode.moveTo(received_pose.mode, {
                                            position: received_pose.position,
                                            rotation: received_pose.rotation,
                                        });

                                        /*                                     await sdk.Sweep.moveTo(received_pose.sweep, { //update camera's position for the last time
                                                                                rotation: received_pose.rotation,
                                                                                transition: sdk.Sweep.Transition.FLY,
                                        
                                                                            }); */


                                    }
                                }

                            });

                            socket.on('sweepid', async msg => { //sync leader and client screen
                                if (hashid !== 1) {
                                    received_pose = msg;
                                    if (received_pose.mode === 'mode.dollhouse' || received_pose.mode === 'mode.floorplan') {
                                        await sdk.Mode.moveTo(received_pose.mode, {
                                            position: received_pose.position,
                                            rotation: received_pose.rotation,
                                        });
                                    }
                                    else {
                                        console.log('SWEEEEEEEEEEEEEP CHANGE');
                                        if (sweepid_cache !== received_pose.sweep) {
                                            await sdk.Sweep.moveTo(msg.sweep, { //receives data and update camera
                                                position: msg.position,
                                                rotation: msg.rotation,
                                                mode: msg.mode,
                                                transition: sdk.Sweep.Transition.FLY,

                                            });
                                        }
                                        else {
                                            console.log('CACHE SWEEP: ' + sweepid_cache);
                                        }
                                    }



                                    //await sdk.Camera.rotate(msg.rotation.x, msg.rotation.y, { speed: 30 });
                                }


                            });




                        })
                        .catch((e) => {
                            console.log('ERROR: ' + e);
                        });
                }
                catch (e) {
                    console.error('ERROR ' + e);
                }
            }
        });
    </script>
</body>

</html>